import Foundation

// MARK: - EngineResolutionError

/// Errors thrown when the ``EngineRegistry`` cannot resolve an engine.
public enum EngineResolutionError: Error, LocalizedError {
    /// No factory registered for the requested modality/engine combination.
    case noEngineRegistered(modality: Modality, engine: Engine?)

    public var errorDescription: String? {
        switch self {
        case .noEngineRegistered(let modality, let engine):
            if let engine = engine {
                return "No engine registered for modality '\(modality.rawValue)' with engine '\(engine.rawValue)'"
            }
            return "No engine registered for modality '\(modality.rawValue)'"
        }
    }
}

// MARK: - EngineRegistry

/// Thread-safe registry mapping (Modality, Engine?) pairs to engine factories.
///
/// The registry follows a two-step resolution chain:
/// 1. Exact match on `(modality, engine)`
/// 2. Fallback to modality default `(modality, nil)`
/// 3. Throw ``EngineResolutionError`` if neither exists.
///
/// Default registrations are installed at init time for all built-in modalities.
/// Extension modules (OctomilMLX, OctomilTimeSeries) can register additional
/// factories at runtime.
public final class EngineRegistry: @unchecked Sendable {

    // MARK: - Types

    /// Composite key for the factory dictionary.
    public struct EngineKey: Hashable, Sendable {
        public let modality: Modality
        public let engine: Engine?

        public init(modality: Modality, engine: Engine? = nil) {
            self.modality = modality
            self.engine = engine
        }
    }

    /// A closure that creates a ``StreamingInferenceEngine`` from a model URL.
    public typealias EngineFactory = @Sendable (URL) throws -> StreamingInferenceEngine

    // MARK: - Singleton

    /// Shared singleton instance with default registrations.
    public static let shared = EngineRegistry()

    // MARK: - State

    private let lock = NSLock()
    private var factories: [EngineKey: EngineFactory] = [:]

    // MARK: - Init

    public init() {
        registerDefaults()
    }

    // MARK: - Registration

    /// Register a factory for a given modality and optional engine.
    ///
    /// - Parameters:
    ///   - modality: The output modality.
    ///   - engine: The specific engine, or `nil` for the modality default.
    ///   - factory: Closure that creates a ``StreamingInferenceEngine`` from a model URL.
    public func register(modality: Modality, engine: Engine? = nil, factory: @escaping EngineFactory) {
        let key = EngineKey(modality: modality, engine: engine)
        lock.lock()
        defer { lock.unlock() }
        factories[key] = factory
    }

    // MARK: - Resolution

    /// Resolve a ``StreamingInferenceEngine`` for the given modality, engine, and model URL.
    ///
    /// Resolution chain:
    /// 1. Exact match `(modality, engine)` if engine is non-nil
    /// 2. Modality default `(modality, nil)`
    /// 3. Throw ``EngineResolutionError``
    ///
    /// - Parameters:
    ///   - modality: The output modality.
    ///   - engine: The specific engine (from URL inference or user choice), or `nil`.
    ///   - modelURL: URL passed to the factory to construct the engine.
    /// - Returns: A configured ``StreamingInferenceEngine``.
    /// - Throws: ``EngineResolutionError`` if no matching factory is found.
    public func resolve(modality: Modality, engine: Engine? = nil, modelURL: URL) throws -> StreamingInferenceEngine {
        lock.lock()
        let snapshot = factories
        lock.unlock()

        // 1. Exact match
        if let engine = engine {
            let exactKey = EngineKey(modality: modality, engine: engine)
            if let factory = snapshot[exactKey] {
                return try factory(modelURL)
            }
        }

        // 2. Modality default
        let defaultKey = EngineKey(modality: modality, engine: nil)
        if let factory = snapshot[defaultKey] {
            return try factory(modelURL)
        }

        // 3. No match
        throw EngineResolutionError.noEngineRegistered(modality: modality, engine: engine)
    }

    // MARK: - URL-based Engine Inference

    /// Infer the ``Engine`` from a model file's extension.
    ///
    /// - `.mlmodelc`, `.mlmodel`, `.mlpackage` -> `.coreml`
    /// - `.safetensors`, `.gguf` -> `.mlx`
    /// - Anything else -> `nil`
    public static func engineFromURL(_ url: URL) -> Engine? {
        switch url.pathExtension.lowercased() {
        case "mlmodelc", "mlmodel", "mlpackage":
            return .coreml
        case "safetensors", "gguf":
            return .mlx
        default:
            return nil
        }
    }

    // MARK: - Reset

    /// Clear all registrations and re-install defaults. Intended for testing.
    public func reset() {
        lock.lock()
        factories.removeAll()
        lock.unlock()
        registerDefaults()
    }

    /// Remove all registrations without re-installing defaults. Intended for testing.
    public func removeAllRegistrations() {
        lock.lock()
        defer { lock.unlock() }
        factories.removeAll()
    }

    // MARK: - Detection & Benchmarking

    /// Detect which engines are available for the given modality on this device.
    /// - Parameter modality: The target modality.
    /// - Returns: Detection results for each known engine.
    public func detectAll(modality: Modality) -> [DetectionResult] {
        // TODO: Probe Metal capabilities, CoreML availability, ANE presence
        // TODO: Return actual availability per engine
        let engines: [Engine] = [.coreml, .mlx]
        return engines.map { engine in
            DetectionResult(engine: engine, available: false, info: nil)
        }
    }

    /// Benchmark all available engines for the given modality and model.
    /// - Parameters:
    ///   - modality: The target modality.
    ///   - modelURL: URL of the model to benchmark.
    ///   - nTokens: Number of tokens to generate during benchmark (default: 32).
    /// - Returns: Ranked engines sorted by tokens-per-second descending.
    public func benchmarkAll(modality: Modality, modelURL: URL, nTokens: Int = 32) async -> [RankedEngine] {
        // TODO: Run short generation on each detected engine
        // TODO: Measure tok/s, TTFT, peak memory
        // TODO: Return sorted results
        return []
    }

    /// Select the best engine from a set of ranked benchmark results.
    /// - Parameter ranked: Results from ``benchmarkAll(modality:modelURL:nTokens:)``.
    /// - Returns: The highest-ranked engine that completed without error, or `nil`.
    public func selectBest(_ ranked: [RankedEngine]) -> RankedEngine? {
        // TODO: Filter by ok, sort by tokensPerSecond descending, pick first
        return ranked.first(where: { $0.result.ok })
    }

    // MARK: - Private

    private func registerDefaults() {
        register(modality: .text) { url in LLMEngine(modelPath: url) }
        register(modality: .image) { url in ImageEngine(modelPath: url) }
        register(modality: .audio) { url in AudioEngine(modelPath: url) }
        register(modality: .video) { url in VideoEngine(modelPath: url) }
        register(modality: .timeSeries) { url in LLMEngine(modelPath: url) }
    }
}
