#if canImport(SwiftUI)
import Foundation
import os.log

/// State of the main-app pairing screen.
///
/// Each case maps to a distinct visual state in ``PairingScreen``.
public enum PairingScreenState: Sendable {
    /// Connecting to the EdgeML server.
    case connecting(host: String)
    /// Downloading the model with progress information.
    case downloading(progress: DownloadProgressInfo)
    /// Pairing completed successfully.
    case success(model: PairedModelInfo)
    /// An error occurred.
    case error(message: String)
}

/// Progress information displayed during model download.
public struct DownloadProgressInfo: Sendable {
    /// Name of the model being downloaded.
    public let modelName: String
    /// Fraction complete (0.0 to 1.0).
    public let fraction: Double
    /// Bytes downloaded so far.
    public let bytesDownloaded: Int64
    /// Total bytes to download.
    public let totalBytes: Int64

    /// Human-readable downloaded size string.
    public var downloadedString: String {
        Self.formatBytes(bytesDownloaded)
    }

    /// Human-readable total size string.
    public var totalString: String {
        Self.formatBytes(totalBytes)
    }

    static func formatBytes(_ bytes: Int64) -> String {
        let gb = Double(bytes) / (1024 * 1024 * 1024)
        if gb >= 1.0 {
            return String(format: "%.1f GB", gb)
        }
        let mb = Double(bytes) / (1024 * 1024)
        return String(format: "%.0f MB", mb)
    }
}

/// Model information displayed on the success screen.
public struct PairedModelInfo: Sendable {
    /// Model display name.
    public let name: String
    /// Model version.
    public let version: String
    /// Human-readable model size.
    public let sizeString: String
    /// Runtime used (e.g. "CoreML").
    public let runtime: String
    /// Tokens per second from the benchmark, if available.
    public let tokensPerSecond: Double?
}

/// Drives the pairing flow for ``PairingScreen``.
///
/// Takes a pairing token and server host extracted from a deep link,
/// runs the full pairing flow via ``PairingManager``, and publishes
/// state updates that the view observes.
///
/// This class is `@MainActor` so all state mutations happen on the main
/// thread, which is required for SwiftUI observation.
@MainActor
public final class PairingViewModel: ObservableObject {

    // MARK: - Published State

    /// Current screen state.
    @Published public private(set) var state: PairingScreenState

    // MARK: - Private

    private let token: String
    private let host: String
    private var pairingTask: Task<Void, Never>?
    private let logger = Logger(subsystem: "ai.edgeml.sdk", category: "PairingViewModel")

    // MARK: - Initialization

    /// Creates a view model for a pairing deep link.
    /// - Parameters:
    ///   - token: Pairing code from the deep link `token` parameter.
    ///   - host: Server URL string from the deep link `host` parameter.
    public init(token: String, host: String) {
        self.token = token
        self.host = host
        self.state = .connecting(host: host)
    }

    deinit {
        pairingTask?.cancel()
    }

    // MARK: - Public API

    /// Starts or restarts the pairing flow.
    public func startPairing() {
        pairingTask?.cancel()
        state = .connecting(host: host)

        pairingTask = Task { [weak self] in
            guard let self else { return }
            await self.runPairingFlow()
        }
    }

    /// Retries after an error.
    public func retry() {
        startPairing()
    }

    // MARK: - Flow

    private func runPairingFlow() async {
        guard let serverURL = URL(string: host.hasPrefix("http") ? host : "https://\(host)") else {
            state = .error(message: "Invalid server URL: \(host)")
            return
        }

        let manager = PairingManager(serverURL: serverURL)

        do {
            // Step 1: Connect
            let session = try await manager.connect(code: token)

            if Task.isCancelled { return }

            // Step 2: Wait for deployment
            let deployment = try await manager.waitForDeployment(code: token, timeout: 300)

            if Task.isCancelled { return }

            // Step 3: Show download progress
            let totalBytes = Int64(deployment.sizeBytes ?? 0)
            state = .downloading(progress: DownloadProgressInfo(
                modelName: deployment.modelName,
                fraction: 0.0,
                bytesDownloaded: 0,
                totalBytes: totalBytes
            ))

            // Simulate early progress while download runs (the PairingManager
            // executeDeployment does not expose incremental progress, so we
            // show an indeterminate-ish progression).
            let progressTask = Task { [weak self] in
                var fraction = 0.1
                while !Task.isCancelled && fraction < 0.9 {
                    try? await Task.sleep(nanoseconds: 500_000_000)
                    guard let self, !Task.isCancelled else { return }
                    fraction = min(fraction + 0.08, 0.9)
                    let downloaded = Int64(Double(totalBytes) * fraction)
                    self.state = .downloading(progress: DownloadProgressInfo(
                        modelName: deployment.modelName,
                        fraction: fraction,
                        bytesDownloaded: downloaded,
                        totalBytes: totalBytes
                    ))
                }
            }

            // Step 4: Execute deployment (download + benchmark)
            let report = try await manager.executeDeployment(deployment)

            progressTask.cancel()

            if Task.isCancelled { return }

            // Step 5: Submit benchmark
            try? await manager.submitBenchmark(code: token, report: report)

            // Step 6: Show success
            let sizeString = DownloadProgressInfo.formatBytes(Int64(deployment.sizeBytes ?? 0))
            let runtime = runtimeDisplayName(deployment.format)

            state = .success(model: PairedModelInfo(
                name: deployment.modelName,
                version: deployment.modelVersion,
                sizeString: sizeString,
                runtime: runtime,
                tokensPerSecond: report.tokensPerSecond
            ))

        } catch is CancellationError {
            // Task was cancelled, do nothing
        } catch let error as PairingError {
            state = .error(message: errorMessage(for: error))
        } catch let error as EdgeMLError {
            state = .error(message: error.localizedDescription)
        } catch {
            state = .error(message: error.localizedDescription)
        }
    }

    // MARK: - Helpers

    private func runtimeDisplayName(_ format: String) -> String {
        switch format.lowercased() {
        case "coreml":
            return "CoreML"
        case "mnn":
            return "MNN"
        case "onnx":
            return "ONNX"
        case "tflite":
            return "TFLite"
        default:
            return format
        }
    }

    private func errorMessage(for error: PairingError) -> String {
        switch error {
        case .sessionExpired:
            return "The pairing session has expired. Please scan a new QR code from the dashboard."
        case .sessionCancelled:
            return "The pairing session was cancelled from the dashboard."
        case .deploymentTimeout:
            return "Timed out waiting for the model deployment. Please try again."
        case .sessionNotFound:
            return "Invalid pairing code. Please scan the QR code again."
        case .downloadFailed(let reason):
            return "Failed to download the model: \(reason)"
        case .invalidDeployment(let reason):
            return "Deployment error: \(reason)"
        case .benchmarkFailed(let reason):
            return "Benchmark failed: \(reason)"
        }
    }
}
#endif
